Ձևավորմանը բերելը. Զանգվածի ձևեր և առանցքներ

Այժմ, երբ տեսել եք NumPy- ի կարողությունների մի մասը, ժամանակն է ամրացնել այդ հիմքը որոշ կարևոր տեսության միջոցով: Կան մի քանի հասկացություններ, որոնք կարևոր են հիշել, հատկապես, երբ աշխատում եք ավելի բարձր չափսերի զանգվածների հետ:
Վեկտորները, որոնք թվերի միաչափ զանգված են, հետևելու համար ամենաքիչը բարդ են: Երկու չափերը նույնպես շատ վատ չեն, քանի որ դրանք նման են աղյուսակներին: Բայց ամեն ինչ սկսում է բարդանալ երեք հարթություններում, և պատկերացնո՞ւմ է չորս: Մոռացիր դրա մասին. 

Վարպետության ձևը
Ձևը հիմնական հասկացությունն է, երբ դուք օգտագործում եք բազմաչափ զանգվածներ: Որոշակի պահի ավելի հեշտ է մոռանալ ձեր տվյալների ձևը պատկերացնելու մասին և փոխարենը պահպանել որոշ մտավոր կանոններ և վստահել NumPy- ին ՝ ձեզ ճիշտ ձև ասելու համար:

Բոլոր զանգվածներն ունեն հատկություն, որը կոչվում է .ձև, որը վերադարձնում է յուրաքանչյուր հարթության չափի տուպլ: Ավելի քիչ կարևոր է, թե որ չափումն է որից, բայց կարևոր է, որ գործառույթներին փոխանցվող զանգվածները լինեն այն ձևի, ինչպիսին սպասում են գործառույթները: Ձեր տվյալների պատշաճ ձևը հաստատելու ընդհանուր ձևը տվյալների և դրանց ձևի տպումն է, մինչև համոզվեք, որ ամեն ինչ կաշխատի այնպես, ինչպես սպասում եք:

Այս հաջորդ օրինակը ցույց կտա այս գործընթացը: Դուք կստեղծեք բարդ ձև ունեցող զանգված, ստուգեք այն և վերադասավորեք ՝ կարծես թե կարծես.

>>> temperatures = np.array([
...     29.3, 42.1, 18.8, 16.1, 38.0, 12.5,
...     12.6, 49.9, 38.6, 31.3, 9.2, 22.2
... ]).reshape(2, 2, 3)
>>> temperatures.shape
(2, 2, 3)
>>> temperatures
array([[[29.3, 42.1, 18.8],
        [16.1, 38. , 12.5]],

       [[12.6, 49.9, 38.6],
        [31.3,  9.2, 22.2]]])
>>> np.swapaxes(temperatures, 1, 2)
array([[[29.3, 16.1],
        [42.1, 38. ],
        [18.8, 12.5]],

       [[12.6, 31.3],
        [49.9,  9.2],
        [38.6, 22.2]]])
>>>

Այստեղ դուք օգտագործում եք numpy.ndarray մեթոդը, որը կոչվում է .reshape ()՝ 2 × 2 × 3 տվյալների բլոկ ստեղծելու համար: Երբ մուտքագրում 3-ում ստուգում եք ձեր զանգվածի ձևը, դա հենց այն է, ինչ դուք ասել եք, որ լինի: Այնուամենայնիվ, դուք կարող եք տեսնել, թե ինչպես են տպագրված զանգվածները արագ դառնում պատկերավոր երեք կամ ավելի չափսերով: .Swapaxes- ի հետ առանցքները փոխելուց հետո քիչ է պարզվում, թե որ չափումն է որն: Առանցքների մասին ավելին կտեսնեք հաջորդ բաժնում:

Ձևը կրկին կհայտնվի հեռարձակման բաժնում: Առայժմ պարզապես հիշեք, որ այս փոքրիկ ստուգումները ոչինչ չեն արժի: Միշտ կարող եք ջնջել բջիջները կամ ազատվել կոդից, երբ ամեն ինչ սահուն կերպով ընթանա:

Հասկանալ առանցքները
Վերոնշյալ օրինակը ցույց է տալիս, թե որքան կարևոր է իմանալ ոչ միայն ինչ ձևի մեջ են ձեր տվյալները, այլև որ տվյալները որ առանցքում են: NumPy զանգվածներում առանցքները զրոյական ինդեքսավորվում են և որոշում, թե որ չափումն է: Օրինակ, երկչափ զանգվածն ունի ուղղահայաց առանցք (առանցք 0) և հորիզոնական առանցք (առանցք 1): NumPy- ի շատ գործառույթներ և հրամաններ փոխում են իրենց վարքագիծը ՝ ելնելով այն բանից, թե որ առանցքի վրա եք ասում, որ մշակեն:

Այս օրինակը ցույց կտա, թե ինչպես է իրեն պահում .max- ը լռելյայն, առանց առանցքի փաստարկի, և ինչպես է այն փոխում ֆունկցիոնալությունը ՝ կախված այն բանից, թե որ առանցքը եք նշում, երբ առաջարկում եք փաստարկ

>>> table = np.array([
...     [5, 3, 7, 1],
...     [2, 6, 7 ,9],
...     [1, 1, 1, 1],
...     [4, 3, 2, 0],
... ])
>>> table.max()
9
>>> table.max(axis=0)
array([5, 6, 7, 9])
>>> table.max(axis=1)
array([7, 9, 1, 4])

Լռելյայն, .max () - ը վերադարձնում է ամենամեծ արժեքը ամբողջ զանգվածում, անկախ նրանից, թե որքան չափեր կան: Այնուամենայնիվ, հենց որ դուք ընտրեք առանցք, այն կատարում է այդ հաշվարկը տվյալ որոշակի առանցքի երկայնքով արժեքների յուրաքանչյուր հավաքածուի համար: Օրինակ, առանցքի = 0 փաստարկով .max () ընտրում է առավելագույն արժեքը աղյուսակի արժեքների չորս ուղղահայաց հավաքածուներից յուրաքանչյուրում և վերադարձնում է այն զանգվածը, որը հարթեցված է կամ համախմբված է միաչափ զանգվածում:

Իրականում, NumPy- ի գործառույթներից շատերն այս կերպ են վարվում. Եթե առանցք նշված չէ, ապա նրանք գործողություն են կատարում ամբողջ տվյալների բազայի վրա: Հակառակ դեպքում, նրանք գործողությունը կատարում են առանցքային իմաստով:

Հեռարձակում
Մինչ այժմ դուք տեսել եք հեռարձակման մի քանի փոքր օրինակ, բայց թեման կսկսի ավելի իմաստավորել, որքան շատ օրինակներ տեսնեք: Սկզբունքորեն, այն գործում է մեկ կանոնի շուրջ. Զանգվածները կարող են հեռարձակվել միմյանց դեմ, եթե դրանց չափերը համընկնում են, կամ եթե զանգվածներից մեկի չափը 1 է:

Եթե ​​զանգվածները չափի համընկնում են առանցքի երկայնքով, ապա տարրերը կգործարկվեն տարր առ տարր, նման է ներկառուցված Python գործառույթի zip () գործելակերպին: Եթե ​​զանգվածներից մեկի առանցքում 1-ի չափ կա, ապա այդ արժեքը կհեռարձակվի այդ առանցքի երկայնքով, կամ կրկնապատկվի այնքան անգամ, որքան անհրաժեշտ է, որպեսզի մյուս զանգվածում այդ առանցքի երկայնքով տարրերի քանակը համընկնի:

Ահա մի արագ օրինակ: A զանգվածը ունի ձև (4, 1, 8) և B զանգվածը ունի ձև (1, 6, 8): Ելնելով վերը նշված կանոններից ՝ դուք կարող եք միասին աշխատել այս զանգվածների վրա.

0 առանցքում A- ն ունի 4, իսկ B- ն ունի 1, այնպես որ B- ն կարող է հեռարձակվել այդ առանցքի երկայնքով:
1 առանցքում A- ն ունի 1, իսկ B- ն `6, ուստի A- ն կարող է հեռարձակվել այդ առանցքի երկայնքով:
2-րդ առանցքում երկու զանգվածներն ունեն համապատասխան չափեր, այնպես որ նրանք կարող են հաջող գործել:
Բոլոր երեք առանցքները հաջողությամբ հետևում են կանոնին:

Arանգվածները կարող եք կարգավորել այսպես.

>>> A = np.arange(32).reshape(4, 1, 8)
>>> A
array([[[ 0,  1,  2,  3,  4,  5,  6,  7]],

       [[ 8,  9, 10, 11, 12, 13, 14, 15]],

       [[16, 17, 18, 19, 20, 21, 22, 23]],

       [[24, 25, 26, 27, 28, 29, 30, 31]]])
>>> B = np.arange(48).reshape(1, 6, 8)
>>> B
array([[[ 0,  1,  2,  3,  4,  5,  6,  7],
        [ 8,  9, 10, 11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20, 21, 22, 23],
        [24, 25, 26, 27, 28, 29, 30, 31],
        [32, 33, 34, 35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44, 45, 46, 47]]])
>>> A+B
array([[[ 0,  2,  4,  6,  8, 10, 12, 14],
        [ 8, 10, 12, 14, 16, 18, 20, 22],
        [16, 18, 20, 22, 24, 26, 28, 30],
        [24, 26, 28, 30, 32, 34, 36, 38],
        [32, 34, 36, 38, 40, 42, 44, 46],
        [40, 42, 44, 46, 48, 50, 52, 54]],

       [[ 8, 10, 12, 14, 16, 18, 20, 22],
        [16, 18, 20, 22, 24, 26, 28, 30],
        [24, 26, 28, 30, 32, 34, 36, 38],
        [32, 34, 36, 38, 40, 42, 44, 46],
        [40, 42, 44, 46, 48, 50, 52, 54],
        [48, 50, 52, 54, 56, 58, 60, 62]],

       [[16, 18, 20, 22, 24, 26, 28, 30],
        [24, 26, 28, 30, 32, 34, 36, 38],
        [32, 34, 36, 38, 40, 42, 44, 46],
        [40, 42, 44, 46, 48, 50, 52, 54],
        [48, 50, 52, 54, 56, 58, 60, 62],
        [56, 58, 60, 62, 64, 66, 68, 70]],

       [[24, 26, 28, 30, 32, 34, 36, 38],
        [32, 34, 36, 38, 40, 42, 44, 46],
        [40, 42, 44, 46, 48, 50, 52, 54],
        [48, 50, 52, 54, 56, 58, 60, 62],
        [56, 58, 60, 62, 64, 66, 68, 70],
        [64, 66, 68, 70, 72, 74, 76, 78]]])
>>>
Հեռարձակման աշխատանքների ձևն այն է, որ NumPy- ն կրկնապատկում է ինքնաթիռը B- ում երեք անգամ, որպեսզի դու ունենաս ընդհանուր առմամբ չորս ՝ համապատասխանեցնելով A- ի ինքնաթիռների քանակին: Այն նաև կրկնօրինակում է մեկ շարքը A- ում հինգ անգամ, ընդհանուր առմամբ վեց, համապատասխանելով թվին տողերի Բ-ում: Այնուհետև այն ավելացնում է նոր ընդլայնված զանգվածի յուրաքանչյուր տարր իր գործընկերոջը Բ-ի նույն տեղում: Յուրաքանչյուր հաշվարկի արդյունքը ցույց է տալիս ելքի համապատասխան գտնվելու վայրը:

Նշում. Սա լավ միջոց է զանգված ստեղծելու համար ՝ օգտագործելով arange ():

Եվս մեկ անգամ, չնայած կարող եք օգտագործել «հարթություն», «տող» և «սյուն» բառեր ՝ նկարագրելու համար, թե ինչպես են այս օրինակում տրված ձևերը հեռարձակվում ՝ համապատասխանող եռաչափ ձևեր ստեղծելու համար, ավելի բարձր չափսերում ամեն ինչ բարդանում է: Շատ անգամներ ստիպված կլինեք պարզապես հետևել հեռարձակման կանոններին և կատարել բազմաթիվ տպագրություններ ՝ համոզվելու համար, որ ամեն ինչ աշխատում է ինչպես պլանավորված է:

Հեռարձակումը հասկանալը վեկտորացված հաշվարկները յուրացնելու կարևոր մաս է, իսկ վեկտորացված հաշվարկները մաքուր, իդիոմատիկ NumPy կոդ գրելու միջոց են:
