Ձևավորմանը բերելը. Զանգվածի ձևեր և առանցքներ

Այժմ, երբ տեսել եք NumPy- ի կարողությունների մի մասը, ժամանակն է ամրացնել այդ հիմքը որոշ կարևոր տեսության միջոցով: Կան մի քանի հասկացություններ, որոնք կարևոր են հիշել, հատկապես, երբ աշխատում եք ավելի բարձր չափսերի զանգվածների հետ:
Վեկտորները, որոնք թվերի միաչափ զանգված են, հետևելու համար ամենաքիչը բարդ են: Երկու չափերը նույնպես շատ վատ չեն, քանի որ դրանք նման են աղյուսակներին: Բայց ամեն ինչ սկսում է բարդանալ երեք հարթություններում, և պատկերացնո՞ւմ է չորս: Մոռացիր դրա մասին.

Վարպետության ձևը
Ձևը հիմնական հասկացությունն է, երբ դուք օգտագործում եք բազմաչափ զանգվածներ: Որոշակի պահի ավելի հեշտ է մոռանալ ձեր տվյալների ձևը պատկերացնելու մասին և փոխարենը պահպանել որոշ մտավոր կանոններ և վստահել NumPy- ին ՝ ձեզ ճիշտ ձև ասելու համար:

Բոլոր զանգվածներն ունեն հատկություն, որը կոչվում է .ձև, որը վերադարձնում է յուրաքանչյուր հարթության չափի տուպլ: Ավելի քիչ կարևոր է, թե որ չափումն է որից, բայց կարևոր է, որ գործառույթներին փոխանցվող զանգվածները լինեն այն ձևի, ինչպիսին սպասում են գործառույթները: Ձեր տվյալների պատշաճ ձևը հաստատելու ընդհանուր ձևը տվյալների և դրանց ձևի տպումն է, մինչև համոզվեք, որ ամեն ինչ կաշխատի այնպես, ինչպես սպասում եք:

Այս հաջորդ օրինակը ցույց կտա այս գործընթացը: Դուք կստեղծեք բարդ ձև ունեցող զանգված, ստուգեք այն և վերադասավորեք ՝ կարծես թե կարծես.

In [1]: import numpy as np

In [2]: temperatures = np.array([
   ...:     29.3, 42.1, 18.8, 16.1, 38.0, 12.5,
   ...:     12.6, 49.9, 38.6, 31.3, 9.2, 22.2
   ...: ]).reshape(2, 2, 3)

In [3]: temperatures.shape
Out[3]: (2, 2, 3)

In [4]: temperatures
Out[4]:
array([[[29.3, 42.1, 18.8],
        [16.1, 38. , 12.5]],

       [[12.6, 49.9, 38.6],
        [31.3,  9.2, 22.2]]])

In [5]: np.swapaxes(temperatures, 1, 2)
Out[5]:
array([[[29.3, 16.1],
        [42.1, 38. ],
        [18.8, 12.5]],

       [[12.6, 31.3],
        [49.9,  9.2],
        [38.6, 22.2]]])

Այստեղ դուք օգտագործում եք numpy.ndarray մեթոդը, որը կոչվում է .reshape ()՝ 2 × 2 × 3 տվյալների բլոկ ստեղծելու համար: Երբ մուտքագրում 3-ում ստուգում եք ձեր զանգվածի ձևը, դա հենց այն է, ինչ դուք ասել եք, որ լինի: Այնուամենայնիվ, դուք կարող եք տեսնել, թե ինչպես են տպագրված զանգվածները արագ դառնում պատկերավոր երեք կամ ավելի չափսերով: .Swapaxes- ի հետ առանցքները փոխելուց հետո քիչ է պարզվում, թե որ չափումն է որն: Առանցքների մասին ավելին կտեսնեք հաջորդ բաժնում:

Ձևը կրկին կհայտնվի հեռարձակման բաժնում: Առայժմ պարզապես հիշեք, որ այս փոքրիկ ստուգումները ոչինչ չեն արժի: Միշտ կարող եք ջնջել բջիջները կամ ազատվել կոդից, երբ ամեն ինչ սահուն կերպով ընթանա:

Հասկանալ առանցքները
Վերոնշյալ օրինակը ցույց է տալիս, թե որքան կարևոր է իմանալ ոչ միայն ինչ ձևի մեջ են ձեր տվյալները, այլև որ տվյալները որ առանցքում են: NumPy զանգվածներում առանցքները զրոյական ինդեքսավորվում են և որոշում, թե որ չափումն է: Օրինակ, երկչափ զանգվածն ունի ուղղահայաց առանցք (առանցք 0) և հորիզոնական առանցք (առանցք 1): NumPy- ի շատ գործառույթներ և հրամաններ փոխում են իրենց վարքագիծը ՝ ելնելով այն բանից, թե որ առանցքի վրա եք ասում, որ մշակեն:

Այս օրինակը ցույց կտա, թե ինչպես է իրեն պահում .max- ը լռելյայն, առանց առանցքի փաստարկի, և ինչպես է այն փոխում ֆունկցիոնալությունը ՝ կախված այն բանից, թե որ առանցքը եք նշում, երբ առաջարկում եք փաստարկ

In [1]: import numpy as np

In [2]: table = np.array([
   ...:     [5, 3, 7, 1],
   ...:     [2, 6, 7 ,9],
   ...:     [1, 1, 1, 1],
   ...:     [4, 3, 2, 0],
   ...: ])

In [3]: table.max()
Out[3]: 9

In [4]: table.max(axis=0)
Out[4]: array([5, 6, 7, 9])

In [5]: table.max(axis=1)
Out[5]: array([7, 9, 1, 4])

Լռելյայն, .max () - ը վերադարձնում է ամենամեծ արժեքը ամբողջ զանգվածում, անկախ նրանից, թե որքան չափեր կան: Այնուամենայնիվ, հենց որ դուք ընտրեք առանցք, այն կատարում է այդ հաշվարկը տվյալ որոշակի առանցքի երկայնքով արժեքների յուրաքանչյուր հավաքածուի համար: Օրինակ, առանցքի = 0 փաստարկով .max () ընտրում է առավելագույն արժեքը աղյուսակի արժեքների չորս ուղղահայաց հավաքածուներից յուրաքանչյուրում և վերադարձնում է այն զանգվածը, որը հարթեցված է կամ համախմբված է միաչափ զանգվածում:

Իրականում, NumPy- ի գործառույթներից շատերն այս կերպ են վարվում. Եթե առանցք նշված չէ, ապա նրանք գործողություն են կատարում ամբողջ տվյալների բազայի վրա: Հակառակ դեպքում, նրանք գործողությունը կատարում են առանցքային իմաստով:

Հեռարձակում
Մինչ այժմ դուք տեսել եք հեռարձակման մի քանի փոքր օրինակ, բայց թեման կսկսի ավելի իմաստավորել, որքան շատ օրինակներ տեսնեք: Սկզբունքորեն, այն գործում է մեկ կանոնի շուրջ. Զանգվածները կարող են հեռարձակվել միմյանց դեմ, եթե դրանց չափերը համընկնում են, կամ եթե զանգվածներից մեկի չափը 1 է:

Եթե ​​զանգվածները չափի համընկնում են առանցքի երկայնքով, ապա տարրերը կգործարկվեն տարր առ տարր, նման է ներկառուցված Python գործառույթի zip () գործելակերպին: Եթե ​​զանգվածներից մեկի առանցքում 1-ի չափ կա, ապա այդ արժեքը կհեռարձակվի այդ առանցքի երկայնքով, կամ կրկնապատկվի այնքան անգամ, որքան անհրաժեշտ է, որպեսզի մյուս զանգվածում այդ առանցքի երկայնքով տարրերի քանակը համընկնի:

Ահա մի արագ օրինակ: A զանգվածը ունի ձև (4, 1, 8) և B զանգվածը ունի ձև (1, 6, 8): Ելնելով վերը նշված կանոններից ՝ դուք կարող եք միասին աշխատել այս զանգվածների վրա.

0 առանցքում A- ն ունի 4, իսկ B- ն ունի 1, այնպես որ B- ն կարող է հեռարձակվել այդ առանցքի երկայնքով:
1 առանցքում A- ն ունի 1, իսկ B- ն `6, ուստի A- ն կարող է հեռարձակվել այդ առանցքի երկայնքով:
2-րդ առանցքում երկու զանգվածներն ունեն համապատասխան չափեր, այնպես որ նրանք կարող են հաջող գործել:
Բոլոր երեք առանցքները հաջողությամբ հետևում են կանոնին:

Arանգվածները կարող եք կարգավորել այսպես.

In [1]: import numpy as np

In [2]: A = np.arange(32).reshape(4, 1, 8)

In [3]: A
Out[3]:
array([[[ 0,  1,  2,  3,  4,  5,  6,  7]],

       [[ 8,  9, 10, 11, 12, 13, 14, 15]],

       [[16, 17, 18, 19, 20, 21, 22, 23]],

       [[24, 25, 26, 27, 28, 29, 30, 31]]])

In [4]: B = np.arange(48).reshape(1, 6, 8)

In [5]: B
Out[5]:
array([[[ 0,  1,  2,  3,  4,  5,  6,  7],
        [ 8,  9, 10, 11, 12, 13, 14, 15],
        [16, 17, 18, 19, 20, 21, 22, 23],
        [24, 25, 26, 27, 28, 29, 30, 31],
        [32, 33, 34, 35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44, 45, 46, 47]]])
In [7]: A + B
Out[7]:
array([[[ 0,  2,  4,  6,  8, 10, 12, 14],
        [ 8, 10, 12, 14, 16, 18, 20, 22],
        [16, 18, 20, 22, 24, 26, 28, 30],
        [24, 26, 28, 30, 32, 34, 36, 38],
        [32, 34, 36, 38, 40, 42, 44, 46],
        [40, 42, 44, 46, 48, 50, 52, 54]],

       [[ 8, 10, 12, 14, 16, 18, 20, 22],
        [16, 18, 20, 22, 24, 26, 28, 30],
        [24, 26, 28, 30, 32, 34, 36, 38],
        [32, 34, 36, 38, 40, 42, 44, 46],
        [40, 42, 44, 46, 48, 50, 52, 54],
        [48, 50, 52, 54, 56, 58, 60, 62]],

       [[16, 18, 20, 22, 24, 26, 28, 30],
        [24, 26, 28, 30, 32, 34, 36, 38],
        [32, 34, 36, 38, 40, 42, 44, 46],
        [40, 42, 44, 46, 48, 50, 52, 54],
        [48, 50, 52, 54, 56, 58, 60, 62],
        [56, 58, 60, 62, 64, 66, 68, 70]],

       [[24, 26, 28, 30, 32, 34, 36, 38],
        [32, 34, 36, 38, 40, 42, 44, 46],
        [40, 42, 44, 46, 48, 50, 52, 54],
        [48, 50, 52, 54, 56, 58, 60, 62],
        [56, 58, 60, 62, 64, 66, 68, 70],
        [64, 66, 68, 70, 72, 74, 76, 78]]])
Հեռարձակման աշխատանքների ձևն այն է, որ NumPy- ն կրկնապատկում է ինքնաթիռը B- ում երեք անգամ, որպեսզի դու ունենաս ընդհանուր առմամբ չորս ՝ համապատասխանեցնելով A- ի ինքնաթիռների քանակին: Այն նաև կրկնօրինակում է մեկ շարքը A- ում հինգ անգամ, ընդհանուր առմամբ վեց, համապատասխանելով թվին տողերի Բ-ում: Այնուհետև այն ավելացնում է նոր ընդլայնված զանգվածի յուրաքանչյուր տարր իր գործընկերոջը Բ-ի նույն տեղում: Յուրաքանչյուր հաշվարկի արդյունքը ցույց է տալիս ելքի համապատասխան գտնվելու վայրը:

Նշում. Սա լավ միջոց է զանգված ստեղծելու համար ՝ օգտագործելով arange ():

Եվս մեկ անգամ, չնայած կարող եք օգտագործել «հարթություն», «տող» և «սյուն» բառեր ՝ նկարագրելու համար, թե ինչպես են այս օրինակում տրված ձևերը հեռարձակվում ՝ համապատասխանող եռաչափ ձևեր ստեղծելու համար, ավելի բարձր չափսերում ամեն ինչ բարդանում է: Շատ անգամներ ստիպված կլինեք պարզապես հետևել հեռարձակման կանոններին և կատարել բազմաթիվ տպագրություններ ՝ համոզվելու համար, որ ամեն ինչ աշխատում է ինչպես պլանավորված է:

Հեռարձակումը հասկանալը վեկտորացված հաշվարկները յուրացնելու կարևոր մաս է, իսկ վեկտորացված հաշվարկները մաքուր, իդիոմատիկ NumPy կոդ գրելու միջոց են:

Տվյալների գիտության գործառնություններ. Զտիչ, կարգ, համախառն
Դա պարունակում է մի հատված, որը տեսականորեն ծանր էր, բայց մի փոքր թեթև էր գործնական, իրական օրինակների վրա: Այս բաժնում դուք կաշխատեք տվյալների գիտության իրական, օգտակար գործառնությունների մի քանի օրինակների միջոցով ՝ տվյալների զտում, տեսակավորում և համախմբում:

Ինդեքսավորումը
Ինդեքսավորումը օգտագործում է նույն նույն բառապաշարներից շատերը, որոնք օգտագործում է բնական Python կոդը: Զանգվածի առջևից կամ հետևից ինդեքսավորելու համար կարող եք օգտագործել դրական կամ բացասական ցուցանիշներ: Կարող եք օգտագործել երկու կետ (:) ՝ «մնացածը» կամ «բոլորը» նշելու համար, և կարող ես նույնիսկ օգտագործել երկու կետ ՝ տարրերը բաց թողնելու համար, ինչպես սովորական Python ցուցակներով:

Ահա տարբերությունը. NumPy զանգվածներն օգտագործում են ստորակետեր առանցքների միջև, այնպես որ կարող եք ինդեքսավորել բազմաթիվ առանցքներ մեկ քառակուսի փակագծերում: Օրինակ ցույց տալը ամենադյուրին ճանապարհն է: Ժամանակն է հաստատել Դյուրերի կախարդական հրապարակը:

Ստորև ներկայացված քառակուսին ունի զարմանալի հատկություններ: Եթե ​​շարքերից, սյուններից կամ անկյունագծերից որևէ մեկը ավելացնեք, ապա այդ նույն թիվը կստանաք 34-ը: Դա նաև այն է, ինչ կստանաք, եթե ավելացնեք չորս քառակուսիներից յուրաքանչյուրը, կենտրոնի չորս քառակուսիները, չորս անկյունները: քառակուսիներ կամ պարունակվող 3 × 3 ցանցերից որևէ չորս անկյունային քառակուսիները: Դուք ապացուցելու եք դա:

Զվարճալի փաստ. Ստորին շարքում 15 և 14 թվերը մեջտեղում են, որոնք ներկայացնում են այն տարին, երբ Դյուրերը ստեղծեց այս հրապարակը: Այդ շարքում են նաև 1 և 4 թվերը, որոնք ներկայացնում են այբուբենի առաջին և չորրորդ տառերը ՝ A և D, որոնք հրապարակի ստեղծողի ՝ Ալբրեխտ Դյուրերի սկզբնատառերն են:

Մուտքագրեք հետևյալը ձեր REPL- ում.

In [1]: import numpy as np

In [2]: square = np.array([
   ...:     [16, 3, 2, 13],
   ...:     [5, 10, 11, 8],
   ...:     [9, 6, 7, 12],
   ...:     [4, 15, 14, 1]
   ...: ])

In [3]: for i in range(4):
   ...:     assert square[:, i].sum() == 34
   ...:     assert square[i, :].sum() == 34
   ...:

In [4]: assert square[:2, :2].sum() == 34

In [5]: assert square[2:, :2].sum() == 34

In [6]: assert square[:2, 2:].sum() == 34

In [7]: assert square[2:, 2:].sum() == 34

For օղակի ներսում դուք հաստատում եք, որ բոլոր տողերն ու բոլոր սյունակները ավելանում են մինչև 34: Դրանից հետո, օգտագործելով ընտրողական ինդեքսավորումը, դուք հաստատում եք, որ քառակուսիներից յուրաքանչյուրը նաև ավելացնում է 34:

Մի վերջին բանը, որ պետք է նշել, այն է, որ դուք ի վիճակի եք վերցնել ցանկացած զանգվածի գումար `դրա բոլոր տարրերն ամբողջությամբ ավելացնելով square.sum (): Այս մեթոդը կարող է նաև վերցնել առանցքի փաստարկ, որպեսզի փոխարենը կատարվի առանցքի իմաստով ամփոփում:

Դիմակավորում և զտում
Ինդեքսի վրա հիմնված ընտրությունը հիանալի է, բայց ի՞նչ կլինի, եթե ցանկանում եք զտել ձեր տվյալները ՝ հիմնվելով ավելի բարդ ոչ միատարր կամ ոչ հետևողական չափանիշների վրա: Հենց այստեղ է, որ խաղում է դիմակ հասկացությունը:

Դիմակը զանգված է, որն ունի ճիշտ նույն ձևը, ինչ ձեր տվյալները, բայց ձեր արժեքների փոխարեն այն պարունակում է բուլյան արժեքներ. Կա՛մ ճշմարիտ, կա՛մ սխալ: Այս դիմակի զանգվածը կարող եք օգտագործել ձեր տվյալների զանգվածը ոչ գծային և բարդ ձևերով ինդեքսավորելու համար: Այն կվերադարձնի բոլոր այն տարրերը, որտեղ բուլյան զանգվածը ունի իրական արժեք:

Ահա մի գործընթաց, որը ցույց է տալիս գործընթացը ՝ նախ դանդաղ շարժման մեջ, և հետո, թե ինչպես է դա սովորաբար արվում, բոլորը մեկ տողով.

In [1]: import numpy as np

In [2]: numbers = np.linspace(5, 50, 24, dtype=int).reshape(4, -1)

In [3]: numbers
Out[3]:
array([[ 5, 6,  8, 10, 12, 14],
       [16, 18, 20, 22, 24, 26],
       [28, 30, 32, 34, 36, 38],
       [40, 42, 44, 46, 48, 50]])

In [4]: mask = numbers % 4 == 0

In [5]: mask
Out[5]:
array([[False, False,  True, False,  True, False],
       [ True, False,  True, False,  True, False],
       [ True, False,  True, False,  True, False],
       [ True, False,  True, False,  True, False]])

In [6]: numbers[mask]
Out[6]: array([ 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48])

In [7]: by_four = numbers[numbers % 4 == 0]

In [8]: by_four
Out[8]: array([ 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48])

Միանգամից կտեսնեք զանգվածի ստեղծման նոր հնարքների բացատրությունը մուտքի 2-ում, բայց հիմա կենտրոնացեք օրինակի մսի վրա: Սրանք կարևոր մասերն են.

Մուտք 4-ը դիմակը ստեղծում է ՝ կատարելով վեկտորացված Բուլյան հաշվարկ, վերցնելով յուրաքանչյուր տարր և ստուգելով, արդյոք այն հավասարապես բաժանվում է չորսի: Սա վերադարձնում է նույն ձևի դիմակի զանգված ՝ հաշվարկման տարրական արդյունքների հետ:
Մուտք 6-ը օգտագործում է այս դիմակը ՝ ինդեքսավորելու համար սկզբնական թվերի զանգվածը: Սա հանգեցնում է նրան, որ զանգվածը կկորցնի իր սկզբնական ձևը ՝ այն հասցնելով մեկ հարթության, բայց դուք դեռ ստանում եք ձեր փնտրած տվյալները:
Մուտք 7-ը տալիս է ավելի ավանդական, իդիոմատիկ դիմակավորված ընտրություն, որը կարող եք տեսնել վայրի բնության մեջ, ընտրության փակագծերի ներսում ստեղծվել է անանուն զտիչ զանգվածով: Այս շարահյուսությունը նման է օգտագործման R ծրագրավորման լեզվին:
Վերադառնալով մուտքագրում 2-ին ՝ դուք բախվում եք երեք նոր հասկացությունների.

Օգտագործելով np.linspace () ՝ հավասարաչափ տարածված զանգված ստեղծելու համար
Արդյունքի dtype- ի տեղադրում
Rayանգվածը վերաձեւավորվում է -1-ով
np.linspace () առաջացնում է n թվեր հավասարաչափ բաշխված նվազագույնի և առավելագույնի միջև, ինչը օգտակար է գիտական ​​գծագրերում հավասարաչափ բաշխված նմուշառման համար:

Այս օրինակում առկա հատուկ հաշվարկի պատճառով կյանքն ավելի հեշտ է դառնում թվերի զանգվածում ունենալ ամբողջ թվեր: Բայց քանի որ 5-ի և 50-ի միջակայքը հավասարապես չի բաժանվում 24-ի, ստացված թվերը կլինեն լողացող կետերի թվեր: Դուք նշում եք int- ի մի տեսակ `գործառույթը ստիպելու համար շրջվել ներքև և տալ ձեզ ամբողջ ամբողջ թվեր: Ավելի ուշ կտեսնեք տվյալների տեսակների ավելի մանրամասն քննարկում:

Վերջապես, array.reshape- ը () կարող է վերցնել -1-ը `իր չափի չափերից մեկը: Դա նշանակում է, որ NumPy- ն ուղղակի պետք է հասկանա, թե որքան մեծ է անհրաժեշտ այդ առանցքը `հիմնվելով մյուս առանցքների չափի վրա: Այս դեպքում, 24 արժեքներով և 0 առանցքում 4 չափսով, առանցքն 1 ավարտվում է 6 չափիով:

Ահա ևս մեկ օրինակ `դիմակավորված զտման հզորությունը ցուցադրելու համար: Նորմալ բաշխումը հավանականության բաշխում է, որում արժեքների մոտավորապես 95,45% -ը տեղի է ունենում միջինից երկու ստանդարտ շեղումների շրջանակներում:

Դուք կարող եք դա հաստատել ՝ պատահական արժեքներ առաջացնելու համար NumPy- ի պատահական մոդուլի մի փոքր օգնությամբ.

In [1]: import numpy as np

In [2]: from numpy.random import default_rng

In [3]: rng = default_rng()

In [4]: values = rng.standard_normal(10000)

In [5]: values[:5]
Out[5]: array([ .9779210858,  1.8361585253,  -.3641365235,
               -.1311344527, 1.286542056 ])

In [6]: std = values.std()

In [7]: std
Out[7]: .9940375551073492

In [8]: filtered = values[(values > -2 * std) & (values < 2 * std)]

In [9]: filtered.size
Out[9]: 9565

In [10]: values.size
Out[10]: 10000

In [11]: filtered.size / values.size
Out[11]: 0.9565

Այստեղ դուք օգտագործում եք պոտենցիալ տարօրինակ տեսքի շարահյուսություն ՝ ֆիլտրի պայմանները համատեղելու համար. Երկուական և օպերատոր: Ինչո՞ւ այդպես կլիներ: Դա այն պատճառով է, որ NumPy- ն նշանակում է & և | որպես վեկտորացված, տարրերի իմաստով օպերատորներ ՝ Booleans- ը միավորելու համար: Եթե փորձեք անել A և B, ապա նախազգուշացում կստանաք այն մասին, թե ինչպես է զանգվածի ճշմարտության արժեքը տարօրինակ, քանի որ և գործում է ամբողջ զանգվածի ճշգրիտ արժեքի վրա, ոչ թե տարր առ տարր:

Տեղափոխում, տեսակավորում և համակցում
Այլ մանիպուլյացիաները, չնայած այնքան տարածված չեն, որքան ինդեքսավորումը կամ զտելը, կարող են նաև շատ հարմար լինել ՝ կախված իրավիճակից, որում գտնվում եք: Այս բաժնում մի քանի օրինակ կտեսնեք:

Ահա զանգված է տեղափոխում ՝

In [1]: import numpy as np

In [2]: a = np.array([
   ...:     [1, 2],
   ...:     [3, 4],
   ...:     [5, 6],
   ...: ])

In [3]: a.T
Out[3]:
array([[1, 3, 5],
       [2, 4, 6]])

In [4]: a.transpose()
Out[4]:
array([[1, 3, 5],
       [2, 4, 6]])

Զանգվածի տեղափոխումը հաշվարկելիս յուրաքանչյուր տողի տողի և սյունակի ցուցիչները փոխվում են: [0, 2] կետը, օրինակ, դառնում է [2, 0] կետ: Դուք կարող եք նաև օգտագործել a- ն որպես a.transpose () - ի կեղծանուն:

Հետևյալ կոդերի բլոկը ցույց է տալիս տեսակավորումը, բայց կառուցվածքային տվյալների առաջիկա բաժնում կտեսնեք նաև տեսակավորման ավելի հզոր տեխնիկա.

In [1]: import numpy as np

In [2]: data = np.array([
   ...:     [7, 1, 4],
   ...:     [8, 6, 5],
   ...:     [1, 2, 3]
   ...: ])

In [3]: np.sort(data)
Out[3]:
array([[1, 4, 7],
       [5, 6, 8],
       [1, 2, 3]])

In [4]: np.sort(data, axis=None)
Out[4]: array([1, 1, 2, 3, 4, 5, 6, 7, 8])

In [5]: np.sort(data, axis=0)
Out[5]:
array([[1, 1, 3],
       [7, 2, 4],
       [8, 6, 5]])

Առանցքի փաստարկը բաց թողնելը ավտոմատ կերպով ընտրում է վերջին և ամենալավ հարթությունը, որը տողերն են այս օրինակում: None- ի օգտագործումը հավասարեցնում է զանգվածը և կատարում գլոբալ տեսակ: Հակառակ դեպքում կարող եք նշել, թե որ առանցքն եք ցանկանում: Արդյունքում 5, զանգվածի յուրաքանչյուր սյուն դեռ ունի իր բոլոր տարրերը, բայց դրանք դասավորված են այդ սյունակի ներսում ցածրից բարձր:

Վերջապես, ահա միացման մի օրինակ: Չնայած կա np.concatenate () գործառույթ, կան նաև մի շարք օգնող գործառույթներ, որոնք երբեմն ավելի հեշտ են ընթերցվում:

Ահա մի քանի օրինակներ.

In [1]: import numpy as np

In [2]: a = np.array([
   ...:     [4, 8],
   ...:     [6, 1]
   ...: ])

In [3]: b = np.array([
   ...:     [3, 5],
   ...:     [7, 2],
   ...: ])

In [4]: np.hstack((a, b))
Out[4]:
array([[4, 8, 3, 5],
       [6, 1, 7, 2]])

In [5]: np.vstack((b, a))
Out[5]:
array([[3, 5],
       [7, 2],
       [4, 8],
       [6, 1]])

In [6]: np.concatenate((a, b))
Out[6]:
array([[4, 8],
       [6, 1],
       [3, 5],
       [7, 2]])

In [7]: np.concatenate((a, b), axis=None)
Out[7]: array([4, 8, 6, 1, 3, 5, 7, 2])

4 և 5 մուտքերը ցույց են տալիս hstack () և vstack () մի փոքր ավելի ինտուիտիվ գործառույթները: 6 և 7 մուտքերը ցույց են տալիս ավելի ընդհանուր համակցված միացում (), նախ առանց առանցքի փաստարկի, ապա առանցքի = Ոչ: Այս տափակ գործելակերպը ձևով նման է այն բանի, ինչ դուք հենց հիմա տեսել եք տեսակավորմամբ ():

Պետք է նշել, որ կարևոր խոչընդոտներից մեկը այն է, որ այս բոլոր գործառույթները որպես առաջին փաստարկ վերցնում են մի շարք զանգվածներ, քան փաստարկների փոփոխական քանակ, ինչպես կարող եք ակնկալել: Կարող եք ասել, քանի որ փակագծերի լրացուցիչ զույգ կա:

Հավաքելով
Գործառույթների այս շրջագայության ձեր վերջին կանգառը նախքան որոշ ավելի առաջադեմ թեմաների և օրինակների մեջ սուզվելը համախմբումն է: Դուք արդեն տեսել եք մի քանի համախմբման մեթոդներ, ներառյալ .sum (), .max (), .mean () և .std (): Ավելին տեսնելու համար կարող եք հղվել գործառույթների ավելի մեծ գրադարանին: Մաթեմատիկական, ֆինանսական և վիճակագրական շատ գործառույթներ օգտագործում են ագրեգացում, որն օգնում է ձեզ կրճատել ձեր տվյալների չափերի քանակը:

Գործնական օրինակ 1. Maclaurin շարքի իրականացումը
Այժմ ժամանակն է տեսնել վերոհիշյալ բաժիններում ներդրված հմտությունների իրատեսական օգտագործման դեպք.

Առանց NumPy- ի մաթեմատիկական հավասարումները ծածկագրերի վերափոխելու ամենադժվար բաներից մեկն այն է, որ տեսողական շատ նմանություններ բացակայում են, ինչը դժվարացնում է ասել, թե ինչ հավասարության բաժին եք դիտում, երբ կարդում եք կոդը: Ամփոփումները վերածվում են օղակների համար ավելի խոսունի, և սահմանափակումների օպտիմալացումներն ավարտվում են օղակների նման:

NumPy- ի օգտագործումը թույլ է տալիս ավելի մոտ լինել մեկից մեկի ներկայացմանը `հավասարումից դեպի ծածկագիր:

Այս հաջորդ օրինակում դուք կոդավորելու եք Maclaurin շարքը նախկինի համար: Maclaurin շարքերը ավելի բարդ գործառույթները մոտավորելու միջոց են `անսահման թվով ամփոփ տերմինների, որոնք կենտրոնացած են մոտ զրոյի:

Նախկինի համար Maclaurin շարքը հետևյալ ամփոփումն է.

Maclauren շարքի հավասարումը e ^ x- ի համար:
Դուք գումարում եք տերմինները ՝ սկսած զրոյից և տեսականորեն անցնելով անսահմանություն: Յուրաքանչյուր n- րդ տերմինը x կբարձրացվի n և կբաժանվի n !, - ով ֆակտորային գործողության նշում է:

Այժմ ժամանակն է, որ դուք դա տեղադրեք NumPy կոդի մեջ: Ստեղծեք ֆայլ, որը կոչվում է maclaurin.py:

from math import e, factorial

import numpy as np

fac = np.vectorize(factorial)

def e_x(x, terms=10):
    """Approximates e^x using a given number of terms of
    the Maclaurin series
    """
    n = np.arange(terms)
    return np.sum((x ** n) / fac(n))

if __name__ == "__main__":
    print("Actual:", e ** 3)  # Using e from the standard library

    print("N (terms)\tMaclaurin\tError")

    for n in range(1, 14):
        maclaurin = e_x(3, terms=n)
        print(f"{n}\t\t{maclaurin:.03f}\t\t{e**3 - maclaurin:.03f}")

Երբ գործարկում եք սա, դուք պետք է տեսնեք հետևյալ արդյունքը.

$ python3 maclaurin.py
Actual: 20.085536923187664
N (terms) Maclaurin Error
1         1.000     19.086
2         4.000     16.086
3         8.500     11.586
4        13.000      7.086
5        16.375      3.711
6        18.400      1.686
7        19.412      0.673
8        19.846      0.239
9        20.009      0.076
10       20.063      0.022
11       20.080      0.006
12       20.084      0.001
13       20.085      0.000

Տերմինների քանակն ավելացնելիս ձեր Maclaurin- ի արժեքը ավելի ու ավելի է մոտենում իրական արժեքին, և ձեր սխալը գնալով փոքրանում է:

Յուրաքանչյուր տերմինի հաշվարկը ենթադրում է x- ի n հզորության տանել և բաժանել n- ի, կամ n- ի գործոնների: Հզորությունների ավելացումը, ամփոփումը և բարձրացումը բոլոր գործողություններն են, որոնք NumPy- ն կարող է ինքնաբերաբար և արագ վեկտորիզացնել, բայց ոչ այնքան գործոնայինի համար ():

Վեկտորացված հաշվարկում գործոն () օգտագործելու համար վեկտորացված տարբերակ ստեղծելու համար հարկավոր է օգտագործել np.vectorize (): Np.vectorize () - ի փաստաթղթերում նշվում է, որ դա ավելին է, քան բարակ փաթաթան, որը տվյալ գործառույթի համար կիրառում է օղակ for: Python- ի նորմալ ծածկագրի փոխարեն այն օգտագործելուց ոչ մի իրական օգուտ չկա, և կան պոտենցիալ որոշ տուգանքներ: Այնուամենայնիվ, ինչպես մի պահ կտեսնեք, ընթերցանության առավելությունները հսկայական են:

Ձեր վեկտորացված ֆակտորիալը տեղ ունենալուց հետո Maclaurin- ի ամբողջ շարքը հաշվարկելու համար իրական ծածկագիրը ցնցող կարճ է: Այն նաև ընթեռնելի է: Ամենակարևորը, գրեթե մեկ առ մեկ է, թե ինչպես է մաթեմատիկական հավասարումը նայում.

n = np.arange(terms)
return np.sum((x ** n) / fac(n))

428 / 5000
Translation results
Սա այնքան կարևոր գաղափար է, որ արժանի է կրկնելու: Բացառությամբ n սկզբնավորելու լրացուցիչ տողի, կոդը կարդում է գրեթե նույնը, ինչ բուն մաթեմատիկական հավասարումը: Ոչ օղակների համար, ոչ ժամանակավոր i, j, k փոփոխականներ: Պարզ, պարզ, մաթեմատիկա:

Միշտ այնպես, դուք օգտագործում եք NumPy մաթեմատիկական ծրագրավորման համար: Լրացուցիչ պրակտիկայի համար փորձեք ընտրել Maclaurin- ի մյուս շարքերից մեկը և իրականացնել այն նման ձևով:

Օպտիմիզացնող պահուստ. Տվյալների տեսակները
Այժմ, երբ դուք մի փոքր ավելի գործնական փորձ ունեք, ժամանակն է վերադառնալ տեսությանը և դիտարկել տվյալների տեսակները: Տվյալների տեսակները կենտրոնական դեր չեն խաղում Python- ի շատ կոդերում: Թվերն աշխատում են այնպես, ինչպես ենթադրվում էր, տողերն այլ բաներ են անում, բուլյան լեզուները ճիշտ են կամ կեղծ, և բացի այդ, դուք ինքներդ եք պատրաստում ձեր առարկաներն ու հավաքածուները:

Այնուամենայնիվ, NumPy- ում կա մի փոքր ավելի մանրամասն, որը պետք է լուսաբանվի: Կատարման օպտիմալացման համար NumPy- ն օգտագործում է C կոդով ծածկույթի տակ, և դա չի կարող անել, քանի դեռ զանգվածի բոլոր կետերը նույն տեսակի չեն: Դա չի նշանակում միայն նույն Python տիպը: Նրանք պետք է լինեն նույն հիմքում ընկած C տիպը, բիտերում նույն ձևի և չափի:

Թվային տեսակները. Int, bool, float և բարդ
Քանի որ ձեր տվյալների գիտության և թվային հաշվարկների մեծ մասը հակված է թվերի ներգրավմանը, դրանք կարծես սկսելու լավագույն վայրը: NumPy ծածկագրում էապես չորս թվային տեսակ կա, և յուրաքանչյուրը կարող է վերցնել մի քանի տարբեր չափսեր:

Ստորև բերված աղյուսակը ցույց է տալիս այս տեսակների մանրամասները.

Name	     # of Bits	Python Type	NumPy Type
Integer	      64	       int	    np.int_
Booleans	     8	      bool	    np.bool_
Float	        64	     float	    np.float_
Complex	     128	   complex	    np.complex_

Սրանք ընդամենը այն տիպերն են, որոնք քարտեզագրում են գոյություն ունեցող Python տիպերին: NumPy- ն ունի նաև տիպեր յուրաքանչյուրի փոքր չափի տարբերակների համար, ինչպիսիք են 8-, 16 և 32 բիթանոց ամբողջ թվերը, 32-բիթանոց մեկ ճշգրիտ լողացող կետի համարները և 64-բիթանոց մեկ ճշգրիտ բարդ թվերը: Փաստաթղթերում դրանք թվարկված են ամբողջությամբ:

Rayանգվածը ստեղծելու ժամանակ տեսակը նշելու համար կարող եք տրամադրել dtype փաստարկ.

In [1]: import numpy as np

In [2]: a = np.array([1, 3, 5.5, 7.7, 9.2], dtype=np.single)

In [3]: a
Out[3]: array([1. , 3. , 5.5, 7.7, 9.2], dtype=float32)

In [4]: b = np.array([1, 3, 5.5, 7.7, 9.2], dtype=np.uint8)

In [5]: b
Out[5]: array([1, 3, 5, 7, 9], dtype=uint8)

NumPy- ն ավտոմատ կերպով փոխակերպում է ձեր պլատֆորմից անկախ np.sing տիպը `ցանկացած ֆիքսված չափի տեսակի, որն աջակցում է ձեր հարթակն այդ չափի համար: Այս դեպքում այն օգտագործում է np.float32: Եթե ձեր տրամադրած արժեքները չեն համընկնում ձեր տրամադրած dtype- ի ձևի հետ, ապա NumPy- ն այն կամ կուղղի ձեզ համար, կամ սխալ կբարձրացնի:

Լարի տեսակները. Չափի յունիկոդ
Լարերը մի փոքր տարօրինակ են պահում NumPy ծածկագրում, քանի որ NumPy- ն պետք է իմանա, թե քանի բայթ է սպասվում, ինչը սովորաբար գործոն չէ Python ծրագրավորման մեջ: Բարեբախտաբար, NumPy- ը բավականին լավ աշխատանք է կատարում ձեզ համար պակաս բարդ գործեր հոգալու հարցում.

In [1]: import numpy as np

In [2]: names = np.array(["bob", "amy", "han"], dtype=str)

In [3]: names
Out[3]: array(['bob', 'amy', 'han'], dtype='<U3')

In [4]: names.itemsize
Out[4]: 12

In [5]: names = np.array(["bob", "amy", "han"])

In [6]: names
Out[6]: array(['bob', 'amy', 'han'], dtype='<U3')

In [7]: more_names = np.array(["bobo", "jehosephat"])

In [8]: np.concatenate((names, more_names))
Out[8]: array(['bob', 'amy', 'han', 'bobo', 'jehosephat'], dtype='<U10')

Մուտք 2-ում դուք տրամադրում եք Python- ի ներկառուցված ստրիպ տիպի տիպ, բայց 3-ի արտադրանքի մեջ այն վերափոխվել է մի փոքր endian Unicode տողի չափի 3-ի: Երբ մուտքագրեք 4-ի տվյալ կետի չափը, տեսնում եք որ դրանք յուրաքանչյուրը 12 բայթ են. երեք 4 բայթանոց Unicode նիշ:

Նշում. NumPy տվյալների տեսակների հետ գործ ունենալիս պետք է մտածել այնպիսի բաների մասին, ինչպիսիք են ձեր արժեքների վերջավորությունը: Այս դեպքում, «<U3» դտիպը նշանակում է, որ յուրաքանչյուր արժեք ունի երեք Unicode նիշի չափ, որի մեջ ամենաքիչը նշանակալից բայթը պահվում է հիշողության մեջ, իսկ ամենաէական բայթը ՝ վերջին: '> U3' - ի տիպը նշանակում է հակառակը:

Որպես օրինակ, NumPy- ն ներկայացնում է «🐍» Unicode նիշը 0xF4 0x01 0x00 բայթով ՝ «<U1» և 0x00 0x01 0xF4 բայթերով ՝ «> U1» տիպով: Փորձեք ՝ ստեղծելով emoji- ով զանգված, դտիպը դնելով մեկին կամ մյուսին, ապա զանգահարելով .tobytes () ձեր զանգվածին:

Եթե ​​ցանկանում եք ուսումնասիրել, թե ինչպես է Python- ը վերաբերվում ձեր Python- ի ձեր սովորական տվյալների տիպերին և զրոներին, ապա կառուցողական գրադարանի պաշտոնական փաստաթղթավորումը, որը ստանդարտ գրադարանի մոդուլ է, որն աշխատում է հում բայթերով, մեկ այլ լավ ռեսուրս է:

Երբ այն համատեղում ես մի զանգվածի հետ, որն ունի ավելի մեծ տարր `8-րդ մուտքագրում նոր զանգված ստեղծելու համար, NumPy- ն օգտակար կերպով պարզում է, թե որքան մեծ պետք է լինեն նոր զանգվածի իրերը, և դրանք բոլորը մեծացնում է <U10 չափի:

Բայց ահա, թե ինչ է պատահում, երբ փորձում եք փոփոխել slots- ներից մեկը, որի արժեքը ավելի մեծ է, քան dtype- ի հզորությունը.

[9] -ում. Անուններ [2] = "jamima"

[10] –ում ՝ անուններ
Դուրս [10]. Զանգված (['bob', 'amy', 'jam'], dtype = '<U3')

Այն չի աշխատում, ինչպես սպասվում էր, և փոխարենը կտրում է ձեր արժեքը: Եթե ​​արդեն զանգված ունեք, ապա NumPy- ի ավտոմատ չափի հայտնաբերումը ձեզ համար չի աշխատի: Դուք ստանում եք երեք նիշ և վերջ: Մնացածը կորչում են դատարկության մեջ:

Այս ամենն ասելու է, որ, ընդհանուր առմամբ, NumPy- ն ձեր մեջքն ունի, երբ լարերի հետ եք աշխատում, բայց միշտ պետք է հսկել ձեր տարրերի չափը և համոզվել, որ բավականաչափ տեղ ունեք, երբ զանգվածները փոփոխեք կամ փոխեք:

Կառուցվածքային զանգվածներ
Ի սկզբանե, դուք իմացաք, որ զանգվածի տարրերը բոլորը պետք է լինեն տվյալների նույն տեսակը, բայց դա ամբողջովին ճիշտ չէր: NumPy- ն ունի հատուկ տեսակի զանգված, որը կոչվում է ռեկորդային զանգված կամ կառուցվածքային զանգված, որի հետ մեկ սյունակի հիման վրա կարող եք նշել տեսակ և, ըստ ցանկության, անուն: Սա էլ ավելի հզոր է դարձնում տեսակավորումը և զտումը, և այն կարող է նման լինել Excel- ում, CSV- ներում կամ հարաբերական շտեմարաններում տվյալների հետ աշխատելուն:

Ահա նրանց մի փոքր ցուցադրելու արագ օրինակ.

In [1]: import numpy as np

In [2]: data = np.array([
   ...:     ("joe", 32, 6),
   ...:     ("mary", 15, 20),
   ...:     ("felipe", 80, 100),
   ...:     ("beyonce", 38, 9001),
   ...: ], dtype=[("name", str, 10), ("age", int), ("power", int)])

In [3]: data[0]
Out[3]: ('joe', 32, 6)

In [4]: data["name"]
Out[4]: array(['joe', 'mary', 'felipe', 'beyonce'], dtype='<U10')

In [5]: data[data["power"] > 9000]["name"]
Out[5]: array(['beyonce'], dtype='<U10')

Մուտք 2-ում դուք ստեղծում եք զանգված, բացառությամբ այն դեպքերի, երբ յուրաքանչյուր տարր տուփ է ՝ անունով, տարիքով և հզորության մակարդակով: Dtype- ի համար դուք իրականում տրամադրում եք տուփերի ցուցակ յուրաքանչյուր դաշտի վերաբերյալ տեղեկատվությամբ. Անունը 10 նիշանոց Unicode դաշտ է, և՛ տարիքը, և՛ հզորությունը ստանդարտ 4-բայթ կամ 8-բայթանոց ամբողջ թիվ են:

Մուտք 3-ում դուք կարող եք տեսնել, որ տողերը, որոնք հայտնի են որպես գրառումներ, մատչելի են `օգտագործելով ինդեքսը:

Մուտք 4-ում դուք տեսնում եք մի նոր շարահյուսություն `ամբողջ սյունակ կամ դաշտ մուտք գործելու համար:

Վերջապես, մուտքագրում 5-ում դուք տեսնում եք դիմակի վրա հիմնված զտման գերհզոր համադրություն `հիմնված դաշտային և դաշտային ընտրության վրա: Ուշադրություն դարձրեք, թե ինչպես այդքան էլ տարբեր չէ կարդալ հետևյալ SQL հարցումը.

SELECT name FROM data
WHERE power > 9000;

Երկու դեպքում էլ ստացվում է անունների ցուցակ, որտեղ էլեկտրաէներգիայի մակարդակը գերազանցում է 9000-ը:

Կարող եք նույնիսկ ավելացնել ORDER BY ֆունկցիոնալությունը ՝ օգտագործելով np.sort ():

In [6]: np.sort(data[data["age"] > 20], order="power")["name"]
Out[6]: array(['joe', 'felipe', 'beyonce'], dtype='<U10')

Սա դասավորում է տվյալները ըստ ուժի ՝ նախքան դրանք առբերելը, ինչը լրացնում է NumPy գործիքների ընտրությունը ՝ ընտրելու, զտելու և տեսակավորելու իրերը, ինչպես կարող եք SQL- ում:

Ավելին տվյալների տեսակների մասին
Ձեռնարկի այս բաժինը նախատեսված է ձեզ համար բավարար գիտելիքներ ստանալու համար `NumPy- ի տվյալների տեսակների հետ արդյունավետ լինելու համար, մի փոքր հասկանալու, թե ինչպես են գործերը աշխատում գլխարկի տակ և ճանաչել որոշ ընդհանուր որոգայթներ: Դա, իհարկե, սպառիչ ուղեցույց չէ: Բաժանման մասին NumPy փաստաթղթերն ունեն ավելի շատ ռեսուրսներ:

Dtype օբյեկտների վերաբերյալ կա նաև շատ ավելի շատ տեղեկատվություն, ներառյալ դրանք կառուցելու, անհատականացնելու և օպտիմալացնելու տարբեր եղանակներ, և ինչպես դրանք ավելի կայուն դարձնել տվյալների մշակման ձեր բոլոր կարիքների համար: Եթե ​​խնդիրներ եք ունենում, և ձեր տվյալները չեն բեռնվում զանգվածներում, ինչպես սպասում եք, ապա դա լավ տեղ է սկսելու համար:

Վերջապես, NumPy- ի հավաքածուն ինքնին հզոր օբյեկտ է, և դուք իսկապես քերծել եք միայն կառուցվածքային շտեմարանների հնարավորությունների մակերեսը: Անշուշտ արժե կարդալ վերականգնման փաստաթղթերը, ինչպես նաև այլ մասնագիտացված զանգվածի ենթադասերի փաստաթղթերը, որոնք տրամադրում է NumPy- ն:

Առջևում հայացք ՝ ավելի հզոր գրադարաններ
Այս հաջորդ բաժնում դուք կանցնեք էլեկտրակայանի գործիքներին, որոնք կառուցված են վերևում տեսած հիմնարար շենքերի բլոկների վերևում: Ահա այն գրադարաններից մի քանիսը, որոնք կցանկանաք դիտել որպես ձեր հաջորդ քայլերը Python- ի տվյալների ամբողջական գիտության տիրապետման ճանապարհին:

պանդաներ
pandas- ը գրադարան է, որը վերցնում է կառուցվածքային զանգվածների գաղափարը և այն կառուցում բազում հարմարավետության մեթոդների, մշակողների փորձի բարելավման և ավելի լավ ավտոմատացման միջոցով: Եթե ​​Ձեզ անհրաժեշտ է հիմնականում տվյալներ ներմուծել ցանկացած վայրից, մաքրել դրանք, վերաձեւակերպել դրանք, փայլեցնել դրանք, ապա արտահանել դրանք հիմնականում ցանկացած ձևաչափի, ապա pandas- ը ձեզ համար գրադարան է: Հավանական է, որ ինչ-որ պահի դուք pandas ներմուծեք որպես pd, միևնույն ժամանակ numpy ներմուծեք որպես np:

Պանդաների փաստաթղթերն ունեն արագ ձեռնարկ, որը լցված է կոնկրետ օրինակներով, որոնք կոչվում են 10 րոպե դեպի պանդաներ: Դա հիանալի ռեսուրս է, որը կարող եք օգտագործել արագ և գործնական պրակտիկա ձեռք բերելու համար:

ճեղքել-սովորել
Եթե ​​ձեր նպատակներն ավելի շատ մեքենայական ուսուցման ուղղությամբ են, ապա հաջորդ քայլը կտրուկ սովորելն է: Հաշվի առնելով բավարար տվյալներ, դուք կարող եք կատարել դասակարգում, հետընթաց, կլաստերացում և ավելին ընդամենը մի քանի տողում:

Եթե ​​ձեզ արդեն իսկ հարմար է մաթեմատիկան, ուրեմն կտրուկ ուսուցման փաստաթղթերը պարունակում են ձեռնարկների հիանալի ցուցակ Python- ում ձեզ գործի դնելու համար: Եթե ​​ոչ, ապա Մաթեմատիկա տվյալների գիտության ուսուցման ուղին լավ տեղ է սկսելու համար: Բացի այդ, կա նաև մեքենայական ուսուցման մի ամբողջ ուսուցման ուղի:

Քեզ համար կարևոր է հասկանալ գոնե ալգորիթմների հիմքում ընկած մաթեմատիկայի հիմունքները, այլ ոչ թե դրանք պարզապես ներմուծել և գործարկել դրանց հետ: Մեքենայական ուսուցման մոդելներում կողմնակալությունը էթիկական, սոցիալական և քաղաքական հսկայական խնդիր է:

Տվյալների նետումը մոդելների վրա ՝ առանց հաշվի առնելու, թե ինչպես կողմնորոշվել կողմնակալությունը, հիանալի միջոց է փորձանքի մեջ ընկնելու և մարդկանց կյանքի վրա բացասաբար ազդելու համար: Որոշակի հետազոտություն կատարելը և սովորելը, թե ինչպես կանխատեսել, թե որտեղ կարող է լինել կողմնակալություն, լավ սկիզբ է ճիշտ ուղղությամբ:

Մատպլոտլիբ
Անկախ այն բանից, թե ինչ եք անում ձեր տվյալների հետ, ինչ-որ պահի դուք պետք է ձեր արդյունքները հաղորդեք այլ մարդկանց, և Matplotlib- ը դա իրականացնելու հիմնական գրադարաններից մեկն է: Ներածություն ստանալու համար տե՛ս Matplotlib- ի հետ գծագրություններ: Հաջորդ բաժնում դուք կստանաք մի քանի գործնական պրակտիկա Matplotlib- ի հետ, բայց դուք այն կօգտագործեք ավելի շուտ պատկերների մանիպուլյացիայի համար, քան սյուժեներ պատրաստելու համար:

Գործնական օրինակ 2. Մատպլոտլիբով պատկերների մանիպուլյացիա
Միշտ էլ կոկիկ է, երբ աշխատում եք Python գրադարանի հետ, և այն ձեզ փոխանցում է մի բան, որը, պարզվում է, NumPy հիմնական զանգված է: Այս օրինակում դա կտեսնեք իր ողջ փառքով:

Դուք պատրաստվում եք բեռնել պատկեր Matplotlib- ի միջոցով, գիտակցել, որ RGB պատկերները իրականում ընդամենը int8 ամբողջ թվերի լայնության × բարձրության × 3 զանգված են, շահարկեք այդ բայթերը և Matplotlib- ը կրկին օգտագործեք ՝ այդ փոփոխված պատկերը պահելու համար:

Ներբեռնեք այս պատկերը ՝ հետ աշխատելու համար.

Դա պաշտելի ձագի պատկեր է, որը 1920 պիքսել է 1299 պիքսելով: Դուք փոխելու եք այդ պիքսելների գույները:

Ստեղծեք Python ֆայլ, որը կոչվում է image_mod.py, ապա կարգավորեք ձեր ներմուծումները և բեռնեք պատկերը.

import numpy as np
import matplotlib.image as mpimg

img = mpimg.imread("kitty.jpg")
print(type(img))
print(img.shape)

Սա լավ սկիզբ է: Matplotlib- ն ունի պատկերների մշակման իր սեփական մոդուլը, և դուք ապավինելու եք դրան, քանի որ դա պարզ է դարձնում պատկերների ձևաչափեր կարդալ և գրել:

Եթե դուք գործարկում եք այս կոդը, ապա ձեր ընկերոջը `NumPy զանգվածը, կհայտնվի արտադրանքի մեջ.

$ python3 image_mod.py
<class 'numpy.ndarray'>
(1299, 1920, 3)

Դա 1299 պիքսել բարձրությամբ, 1920 պիքսել լայնությամբ և երեք ալիք ունեցող պատկեր է. Յուրաքանչյուրը կարմիր, կանաչ և կապույտ (RGB) գույնի մակարդակների համար:

Wantանկանո՞ւմ եք տեսնել, թե ինչ է պատահում, երբ դուրս եք գալիս R և G ալիքները: Ավելացրեք սա ձեր սցենարին.

output = img.copy()  # The original image is read-only!
output[:, :, :2] = 0
mpimg.imsave("blue.jpg", output)

Կրկին գործարկեք այն և ստուգեք պանակը: Պետք է լինի նոր պատկեր.


Ձեր միտքը դեռ փչե՞լ է: Youգում եք ուժը: Պատկերները պարզապես շքեղ զանգվածներ են: Պիքսելները պարզապես թվեր են:

Բայց հիմա ժամանակն է մի փոքր ավելի օգտակար բան անել: Դուք պատրաստվում եք այս պատկերը փոխակերպել մոխրագույնի: Այնուամենայնիվ, մոխրագույն մասշտաբի վերածվելն ավելի բարդ է: R, G և B ալիքների միջինացումը և դրանք բոլորն էլ նույնը դարձնելը ձեզ կստեղծի մոխրագույնի պատկեր: Բայց մարդու ուղեղը տարօրինակ է, և այդ փոխակերպումը, կարծես, ճիշտ չի կարգավորում գույների պայծառությունը:

Փաստորեն, ավելի լավ է դա ինքներդ տեսնեք: Կարող եք օգտագործել այն փաստը, որ եթե զանգված եք դուրս բերում միայն մեկ ալիքով, այլ ոչ թե երեք, ապա կարող եք նշել գունավոր քարտեզը, որը Matplotlib աշխարհում հայտնի է որպես cmap: Եթե դուք նշում եք cmap, ապա Matplotlib- ը կկատարի ձեզ համար գծային գրադիենտի հաշվարկները:

Ազատվեք ձեր սցենարի վերջին երեք տողերից և դրանք փոխարինեք այսով.

averages = img.mean(axis=2)  # Take the average of each R, G, and B
mpimg.imsave("bad-gray.jpg", averages, cmap="gray")

Այս նոր տողերը ստեղծում են նոր զանգված, որը կոչվում է միջիններ, որը img զանգվածի պատճեն է, որը դուք հարթեցրել եք 2 առանցքի երկայնքով ՝ վերցնելով բոլոր երեք ալիքների միջինը: Դուք միջինացրել եք բոլոր երեք ալիքները և թողարկել եք ինչ-որ բան, որի R, G և B արժեքները հավասար են այդ միջինին: Երբ R, G և B բոլորը նույնն են, ստացված գույնը մոխրագույն մասշտաբի վրա է:

Այն, ինչն ի վերջո տալիս է,
սարսափելի չէ.
